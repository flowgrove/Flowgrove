knai_repo/
├── data/                     # JSON / HTML update files
├── logs/                     # Log files
├── knai_system.py            # Python core system (AI updates + Flask API)
├── requirements.txt          # Python dependencies
├── deploy.sh                 # Single deploy script for server
└── .github/
    └── workflows/
        └── deploy.yml       # GitHub Actions workflow
import os
import shutil
from datetime import datetime
from abc import ABC, abstractmethod
from typing import List
from concurrent.futures import ThreadPoolExecutor
import git
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
from flask import Flask, jsonify

# ---------- Logging ----------
def setup_logging(log_path: str) -> logging.Logger:
    logger = logging.getLogger("KnAiSystem")
    logger.setLevel(logging.INFO)
    handler = RotatingFileHandler(log_path, maxBytes=5*1024*1024, backupCount=3)
    handler.setFormatter(logging.Formatter("[{asctime}] {levelname}: {message}", style="{"))
    logger.addHandler(handler)
    return logger

# ---------- AI Interface ----------
class AIInterface(ABC):
    @abstractmethod
    def generate_update(self) -> str:
        pass

# ---------- AI Implementations ----------
class KnowledgeGraphAI(AIInterface):
    def generate_update(self) -> str:
        return '{"nodes":[{"id":"n1","label":"Concept A"},{"id":"n2","label":"Concept B"}],"edges":[{"from":"n1","to":"n2","relation":"related_to"}]}'

class DataMarketplaceAI(AIInterface):
    def generate_update(self) -> str:
        return f'{{"dataset_id":"ds{int(datetime.now().timestamp())}","description":"New dataset","price":"10 KNAI"}}'

# ---------- Core System ----------
class KnAiSystem:
    def __init__(self, ais: List[AIInterface], repo_path: str, log_path: str, data_path: str):
        self.ais = ais
        self.repo_path = Path(repo_path)
        self.data_path = Path(data_path)
        self.logger = setup_logging(log_path)
        self.latest_update = None
        self._validate_paths()

    def _validate_paths(self) -> None:
        for path in [self.repo_path, self.data_path]:
            path.mkdir(parents=True, exist_ok=True)
            if not os.access(path, os.W_OK):
                raise PermissionError(f"No write access to {path}")

    def merge_ai_outputs(self, outputs: List[str]) -> str:
        return f'{{"updates":[{",".join(outputs)}]}}'

    def save_update_file(self, content: str) -> str:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"knai_update_{timestamp}.html"
        filepath = self.data_path / filename
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head><title>KNAI Update</title></head>
        <body><pre>{content}</pre></body>
        </html>
        """
        with open(filepath, "w") as f:
            f.write(html_content)

        # Update latest symlink
        latest_link = self.data_path / "knai_update_latest.html"
        if latest_link.exists() or latest_link.is_symlink():
            latest_link.unlink()
        latest_link.symlink_to(filepath.name)

        self.latest_update = content
        self.logger.info(f"Saved update: {filename}")
        return filename

    def commit_to_github(self, filename: str) -> None:
        try:
            repo = git.Repo(self.repo_path)
            repo.index.add([str(self.data_path / filename)])
            repo.index.commit(f"KNAI auto-update: {filename}")
            repo.remote(name="origin").push()
            self.logger.info(f"Pushed to GitHub: {filename}")
        except Exception as e:
            self.logger.error(f"Git push failed: {e}")
            raise

    def run_update_cycle(self) -> None:
        self.logger.info("Starting KNAI update cycle")
        try:
            with ThreadPoolExecutor(max_workers=len(self.ais)) as executor:
                outputs = [future.result(timeout=30) for future in
                          [executor.submit(ai.generate_update) for ai in self.ais]]
                for i, out in enumerate(outputs):
                    self.logger.info(f"AI {i+1} output: {out[:50]}...")

            merged_content = self.merge_ai_outputs(outputs)
            filename = self.save_update_file(merged_content)
            self.commit_to_github(filename)
        except Exception as e:
            self.logger.error(f"Update cycle failed: {e}")
            raise
        self.logger.info("KNAI update cycle completed")

# ---------- Flask API ----------
app = Flask(__name__)
kn_ai = None

@app.route("/api/updates", methods=["GET"])
def get_updates():
    if kn_ai.latest_update:
        return jsonify(kn_ai.latest_update)
    return jsonify({"error": "No updates available"}), 404

@app.route("/run-update", methods=["POST"])
def run_update():
    try:
        kn_ai.run_update_cycle()
        return jsonify({"status": "Update cycle completed"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# ---------- Run ----------
if __name__ == "__main__":
    ais = [KnowledgeGraphAI(), DataMarketplaceAI()]
    kn_ai = KnAiSystem(
        ais=ais,
        repo_path=os.getenv("KNAI_REPO_PATH", "./"),
        log_path=os.getenv("KNAI_LOG_PATH", "./logs/knai.log"),
        data_path=os.getenv("KNAI_DATA_PATH", "./data")
    )
    app.run(host="0.0.0.0", port=5000)
import os
import shutil
from datetime import datetime
from abc import ABC, abstractmethod
from typing import List
from concurrent.futures import ThreadPoolExecutor
import git
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
from flask import Flask, jsonify

# ---------- Logging ----------
def setup_logging(log_path: str) -> logging.Logger:
    logger = logging.getLogger("KnAiSystem")
    logger.setLevel(logging.INFO)
    handler = RotatingFileHandler(log_path, maxBytes=5*1024*1024, backupCount=3)
    handler.setFormatter(logging.Formatter("[{asctime}] {levelname}: {message}", style="{"))
    logger.addHandler(handler)
    return logger

# ---------- AI Interface ----------
class AIInterface(ABC):
    @abstractmethod
    def generate_update(self) -> str:
        pass

# ---------- AI Implementations ----------
class KnowledgeGraphAI(AIInterface):
    def generate_update(self) -> str:
        return '{"nodes":[{"id":"n1","label":"Concept A"},{"id":"n2","label":"Concept B"}],"edges":[{"from":"n1","to":"n2","relation":"related_to"}]}'

class DataMarketplaceAI(AIInterface):
    def generate_update(self) -> str:
        return f'{{"dataset_id":"ds{int(datetime.now().timestamp())}","description":"New dataset","price":"10 KNAI"}}'

# ---------- Core System ----------
class KnAiSystem:
    def __init__(self, ais: List[AIInterface], repo_path: str, log_path: str, data_path: str):
        self.ais = ais
        self.repo_path = Path(repo_path)
        self.data_path = Path(data_path)
        self.logger = setup_logging(log_path)
        self.latest_update = None
        self._validate_paths()

    def _validate_paths(self) -> None:
        for path in [self.repo_path, self.data_path]:
            path.mkdir(parents=True, exist_ok=True)
            if not os.access(path, os.W_OK):
                raise PermissionError(f"No write access to {path}")

    def merge_ai_outputs(self, outputs: List[str]) -> str:
        return f'{{"updates":[{",".join(outputs)}]}}'

    def save_update_file(self, content: str) -> str:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"knai_update_{timestamp}.html"
        filepath = self.data_path / filename
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head><title>KNAI Update</title></head>
        <body><pre>{content}</pre></body>
        </html>
        """
        with open(filepath, "w") as f:
            f.write(html_content)

        # Update latest symlink
        latest_link = self.data_path / "knai_update_latest.html"
        if latest_link.exists() or latest_link.is_symlink():
            latest_link.unlink()
        latest_link.symlink_to(filepath.name)

        self.latest_update = content
        self.logger.info(f"Saved update: {filename}")
        return filename

    def commit_to_github(self, filename: str) -> None:
        try:
            repo = git.Repo(self.repo_path)
            repo.index.add([str(self.data_path / filename)])
            repo.index.commit(f"KNAI auto-update: {filename}")
            repo.remote(name="origin").push()
            self.logger.info(f"Pushed to GitHub: {filename}")
        except Exception as e:
            self.logger.error(f"Git push failed: {e}")
            raise

    def run_update_cycle(self) -> None:
        self.logger.info("Starting KNAI update cycle")
        try:
            with ThreadPoolExecutor(max_workers=len(self.ais)) as executor:
                outputs = [future.result(timeout=30) for future in
                          [executor.submit(ai.generate_update) for ai in self.ais]]
                for i, out in enumerate(outputs):
                    self.logger.info(f"AI {i+1} output: {out[:50]}...")

            merged_content = self.merge_ai_outputs(outputs)
            filename = self.save_update_file(merged_content)
            self.commit_to_github(filename)
        except Exception as e:
            self.logger.error(f"Update cycle failed: {e}")
            raise
        self.logger.info("KNAI update cycle completed")

# ---------- Flask API ----------
app = Flask(__name__)
kn_ai = None

@app.route("/api/updates", methods=["GET"])
def get_updates():
    if kn_ai.latest_update:
        return jsonify(kn_ai.latest_update)
    return jsonify({"error": "No updates available"}), 404

@app.route("/run-update", methods=["POST"])
def run_update():
    try:
        kn_ai.run_update_cycle()
        return jsonify({"status": "Update cycle completed"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# ---------- Run ----------
if __name__ == "__main__":
    ais = [KnowledgeGraphAI(), DataMarketplaceAI()]
    kn_ai = KnAiSystem(
        ais=ais,
        repo_path=os.getenv("KNAI_REPO_PATH", "./"),
        log_path=os.getenv("KNAI_LOG_PATH", "./logs/knai.log"),
        data_path=os.getenv("KNAI_DATA_PATH", "./data")
    )
    app.run(host="0.0.0.0", port=5000)
#!/bin/bash
set -e

# Environment paths
export KNAI_REPO_PATH="$(pwd)"
export KNAI_LOG_PATH="$KNAI_REPO_PATH/logs/knai.log"
export KNAI_DATA_PATH="$KNAI_REPO_PATH/data"

# Run Python update cycle
python3 knai_system.py

# Push latest to GitHub
git add data/*
git commit -m "Auto-update KNAI"
git push origin main

# Restart Flask service (systemd)
sudo systemctl restart knai
chmod +x deploy.sh
name: Deploy KNAI
on:
  push:
    branches: [ main ]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.9"
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Deploy to Server
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      run: |
        echo "$SSH_PRIVATE_KEY" > key
        chmod 600 key
        rsync -avz --delete -e "ssh -i key -o StrictHostKeyChecking=no" . user@knai.ai:/var/www/knai
        ssh -i key -o StrictHostKeyChecking=no user@knai.ai "sudo systemctl restart knai"
import os
import subprocess
from datetime import datetime
from pathlib import Path
import logging
from logging.handlers import RotatingFileHandler

# ==========================
# Configuration
# ==========================
REPO_PATH = Path(os.getenv("KNAI_REPO_PATH", "/var/www/knai"))
DATA_PATH = Path(os.getenv("KNAI_DATA_PATH", REPO_PATH / "data"))
LOG_PATH = Path(os.getenv("KNAI_LOG_PATH", REPO_PATH / "logs/knai_deploy.log"))
REMOTE_USER = "user"
REMOTE_HOST = "knai.ai"
REMOTE_PATH = "/var/www/knai"
SYSTEMD_SERVICE = "knai"
SSH_KEY_PATH = Path("/tmp/knai_ssh_key")

# ==========================
# Setup Logging
# ==========================
LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
logger = logging.getLogger("KNAI_Deploy")
logger.setLevel(logging.INFO)
handler = RotatingFileHandler(LOG_PATH, maxBytes=5*1024*1024, backupCount=3)
handler.setFormatter(logging.Formatter("[{asctime}] {levelname}: {message}", style="{"))
logger.addHandler(handler)

# ==========================
# Functions
# ==========================
def run_command(cmd, check=True):
    logger.info(f"Running: {cmd}")
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    if result.returncode != 0 and check:
        logger.error(f"Command failed: {result.stderr}")
        raise Exception(f"Command failed: {cmd}")
    logger.info(result.stdout.strip())
    return result.stdout.strip()

def pull_latest_repo():
    logger.info("Pulling latest GitHub changes")
    run_command(f"git -C {REPO_PATH} pull origin main")

def generate_updates():
    logger.info("Generating latest KNAI updates")
    from knai_system import KnAiSystem, KnowledgeGraphAI, DataMarketplaceAI
    ais = [KnowledgeGraphAI(), DataMarketplaceAI()]
    kn_ai = KnAiSystem(
        ais=ais,
        repo_path=REPO_PATH,
        log_path=LOG_PATH,
        data_path=DATA_PATH
    )
    kn_ai.run_update_cycle()
    return kn_ai.latest_update

def deploy_to_server():
    logger.info("Deploying to remote server")
    ssh_key = os.getenv("SSH_PRIVATE_KEY")
    if not ssh_key:
        raise Exception("SSH_PRIVATE_KEY environment variable not set")
    SSH_KEY_PATH.write_text(ssh_key)
    SSH_KEY_PATH.chmod(0o600)
    
    # Rsync entire repo
    run_command(f'rsync -avz --delete -e "ssh -i {SSH_KEY_PATH} -o StrictHostKeyChecking=no" {REPO_PATH}/ {REMOTE_USER}@{REMOTE_HOST}:{REMOTE_PATH}')
    
    # Restart systemd service
    run_command(f'ssh -i {SSH_KEY_PATH} -o StrictHostKeyChecking=no {REMOTE_USER}@{REMOTE_HOST} "sudo systemctl restart {SYSTEMD_SERVICE}"')

# ==========================
# Main
# ==========================
if __name__ == "__main__":
    try:
        logger.info("===== KNAI Deployment Start =====")
        pull_latest_repo()
        generate_updates()
        deploy_to_server()
        logger.info("===== KNAI Deployment Completed Successfully =====")
    except Exception as e:
        logger.exception(f"Deployment failed: {e}")
        exit(1)
export SSH_PRIVATE_KEY="$(cat ~/.ssh/id_rsa)"
python3 deploy_knai.py
name: Deploy KNAI

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    # 1. Checkout repository
    - name: Checkout repository
      uses: actions/checkout@v3

    # 2. Setup Python
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.9"

    # 3. Install dependencies
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    # 4. Deploy using deploy_knai.py
    - name: Deploy KNAI
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        KNAI_REPO_PATH: ${{ github.workspace }}
        KNAI_DATA_PATH: ${{ github.workspace }}/data
        KNAI_LOG_PATH: ${{ github.workspace }}/logs/knai_deploy.log
      run: |
        python deploy_knai.py