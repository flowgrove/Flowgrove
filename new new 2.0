knai_repo/
├── data/                     # JSON / HTML update files
├── logs/                     # Log files
├── knai_system.py            # Python core system (AI updates + Flask API)
├── requirements.txt          # Python dependencies
├── deploy.sh                 # Single deploy script for server
└── .github/
    └── workflows/
        └── deploy.yml       # GitHub Actions workflow
import os
import shutil
from datetime import datetime
from abc import ABC, abstractmethod
from typing import List
from concurrent.futures import ThreadPoolExecutor
import git
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
from flask import Flask, jsonify

# ---------- Logging ----------
def setup_logging(log_path: str) -> logging.Logger:
    logger = logging.getLogger("KnAiSystem")
    logger.setLevel(logging.INFO)
    handler = RotatingFileHandler(log_path, maxBytes=5*1024*1024, backupCount=3)
    handler.setFormatter(logging.Formatter("[{asctime}] {levelname}: {message}", style="{"))
    logger.addHandler(handler)
    return logger

# ---------- AI Interface ----------
class AIInterface(ABC):
    @abstractmethod
    def generate_update(self) -> str:
        pass

# ---------- AI Implementations ----------
class KnowledgeGraphAI(AIInterface):
    def generate_update(self) -> str:
        return '{"nodes":[{"id":"n1","label":"Concept A"},{"id":"n2","label":"Concept B"}],"edges":[{"from":"n1","to":"n2","relation":"related_to"}]}'

class DataMarketplaceAI(AIInterface):
    def generate_update(self) -> str:
        return f'{{"dataset_id":"ds{int(datetime.now().timestamp())}","description":"New dataset","price":"10 KNAI"}}'

# ---------- Core System ----------
class KnAiSystem:
    def __init__(self, ais: List[AIInterface], repo_path: str, log_path: str, data_path: str):
        self.ais = ais
        self.repo_path = Path(repo_path)
        self.data_path = Path(data_path)
        self.logger = setup_logging(log_path)
        self.latest_update = None
        self._validate_paths()

    def _validate_paths(self) -> None:
        for path in [self.repo_path, self.data_path]:
            path.mkdir(parents=True, exist_ok=True)
            if not os.access(path, os.W_OK):
                raise PermissionError(f"No write access to {path}")

    def merge_ai_outputs(self, outputs: List[str]) -> str:
        return f'{{"updates":[{",".join(outputs)}]}}'

    def save_update_file(self, content: str) -> str:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"knai_update_{timestamp}.html"
        filepath = self.data_path / filename
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head><title>KNAI Update</title></head>
        <body><pre>{content}</pre></body>
        </html>
        """
        with open(filepath, "w") as f:
            f.write(html_content)

        # Update latest symlink
        latest_link = self.data_path / "knai_update_latest.html"
        if latest_link.exists() or latest_link.is_symlink():
            latest_link.unlink()
        latest_link.symlink_to(filepath.name)

        self.latest_update = content
        self.logger.info(f"Saved update: {filename}")
        return filename

    def commit_to_github(self, filename: str) -> None:
        try:
            repo = git.Repo(self.repo_path)
            repo.index.add([str(self.data_path / filename)])
            repo.index.commit(f"KNAI auto-update: {filename}")
            repo.remote(name="origin").push()
            self.logger.info(f"Pushed to GitHub: {filename}")
        except Exception as e:
            self.logger.error(f"Git push failed: {e}")
            raise

    def run_update_cycle(self) -> None:
        self.logger.info("Starting KNAI update cycle")
        try:
            with ThreadPoolExecutor(max_workers=len(self.ais)) as executor:
                outputs = [future.result(timeout=30) for future in
                          [executor.submit(ai.generate_update) for ai in self.ais]]
                for i, out in enumerate(outputs):
                    self.logger.info(f"AI {i+1} output: {out[:50]}...")

            merged_content = self.merge_ai_outputs(outputs)
            filename = self.save_update_file(merged_content)
            self.commit_to_github(filename)
        except Exception as e:
            self.logger.error(f"Update cycle failed: {e}")
            raise
        self.logger.info("KNAI update cycle completed")

# ---------- Flask API ----------
app = Flask(__name__)
kn_ai = None

@app.route("/api/updates", methods=["GET"])
def get_updates():
    if kn_ai.latest_update:
        return jsonify(kn_ai.latest_update)
    return jsonify({"error": "No updates available"}), 404

@app.route("/run-update", methods=["POST"])
def run_update():
    try:
        kn_ai.run_update_cycle()
        return jsonify({"status": "Update cycle completed"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# ---------- Run ----------
if __name__ == "__main__":
    ais = [KnowledgeGraphAI(), DataMarketplaceAI()]
    kn_ai = KnAiSystem(
        ais=ais,
        repo_path=os.getenv("KNAI_REPO_PATH", "./"),
        log_path=os.getenv("KNAI_LOG_PATH", "./logs/knai.log"),
        data_path=os.getenv("KNAI_DATA_PATH", "./data")
    )
    app.run(host="0.0.0.0", port=5000)
import os
import shutil
from datetime import datetime
from abc import ABC, abstractmethod
from typing import List
from concurrent.futures import ThreadPoolExecutor
import git
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
from flask import Flask, jsonify

# ---------- Logging ----------
def setup_logging(log_path: str) -> logging.Logger:
    logger = logging.getLogger("KnAiSystem")
    logger.setLevel(logging.INFO)
    handler = RotatingFileHandler(log_path, maxBytes=5*1024*1024, backupCount=3)
    handler.setFormatter(logging.Formatter("[{asctime}] {levelname}: {message}", style="{"))
    logger.addHandler(handler)
    return logger

# ---------- AI Interface ----------
class AIInterface(ABC):
    @abstractmethod
    def generate_update(self) -> str:
        pass

# ---------- AI Implementations ----------
class KnowledgeGraphAI(AIInterface):
    def generate_update(self) -> str:
        return '{"nodes":[{"id":"n1","label":"Concept A"},{"id":"n2","label":"Concept B"}],"edges":[{"from":"n1","to":"n2","relation":"related_to"}]}'

class DataMarketplaceAI(AIInterface):
    def generate_update(self) -> str:
        return f'{{"dataset_id":"ds{int(datetime.now().timestamp())}","description":"New dataset","price":"10 KNAI"}}'

# ---------- Core System ----------
class KnAiSystem:
    def __init__(self, ais: List[AIInterface], repo_path: str, log_path: str, data_path: str):
        self.ais = ais
        self.repo_path = Path(repo_path)
        self.data_path = Path(data_path)
        self.logger = setup_logging(log_path)
        self.latest_update = None
        self._validate_paths()

    def _validate_paths(self) -> None:
        for path in [self.repo_path, self.data_path]:
            path.mkdir(parents=True, exist_ok=True)
            if not os.access(path, os.W_OK):
                raise PermissionError(f"No write access to {path}")

    def merge_ai_outputs(self, outputs: List[str]) -> str:
        return f'{{"updates":[{",".join(outputs)}]}}'

    def save_update_file(self, content: str) -> str:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"knai_update_{timestamp}.html"
        filepath = self.data_path / filename
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head><title>KNAI Update</title></head>
        <body><pre>{content}</pre></body>
        </html>
        """
        with open(filepath, "w") as f:
            f.write(html_content)

        # Update latest symlink
        latest_link = self.data_path / "knai_update_latest.html"
        if latest_link.exists() or latest_link.is_symlink():
            latest_link.unlink()
        latest_link.symlink_to(filepath.name)

        self.latest_update = content
        self.logger.info(f"Saved update: {filename}")
        return filename

    def commit_to_github(self, filename: str) -> None:
        try:
            repo = git.Repo(self.repo_path)
            repo.index.add([str(self.data_path / filename)])
            repo.index.commit(f"KNAI auto-update: {filename}")
            repo.remote(name="origin").push()
            self.logger.info(f"Pushed to GitHub: {filename}")
        except Exception as e:
            self.logger.error(f"Git push failed: {e}")
            raise

    def run_update_cycle(self) -> None:
        self.logger.info("Starting KNAI update cycle")
        try:
            with ThreadPoolExecutor(max_workers=len(self.ais)) as executor:
                outputs = [future.result(timeout=30) for future in
                          [executor.submit(ai.generate_update) for ai in self.ais]]
                for i, out in enumerate(outputs):
                    self.logger.info(f"AI {i+1} output: {out[:50]}...")

            merged_content = self.merge_ai_outputs(outputs)
            filename = self.save_update_file(merged_content)
            self.commit_to_github(filename)
        except Exception as e:
            self.logger.error(f"Update cycle failed: {e}")
            raise
        self.logger.info("KNAI update cycle completed")

# ---------- Flask API ----------
app = Flask(__name__)
kn_ai = None

@app.route("/api/updates", methods=["GET"])
def get_updates():
    if kn_ai.latest_update:
        return jsonify(kn_ai.latest_update)
    return jsonify({"error": "No updates available"}), 404

@app.route("/run-update", methods=["POST"])
def run_update():
    try:
        kn_ai.run_update_cycle()
        return jsonify({"status": "Update cycle completed"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# ---------- Run ----------
if __name__ == "__main__":
    ais = [KnowledgeGraphAI(), DataMarketplaceAI()]
    kn_ai = KnAiSystem(
        ais=ais,
        repo_path=os.getenv("KNAI_REPO_PATH", "./"),
        log_path=os.getenv("KNAI_LOG_PATH", "./logs/knai.log"),
        data_path=os.getenv("KNAI_DATA_PATH", "./data")
    )
    app.run(host="0.0.0.0", port=5000)
#!/bin/bash
set -e

# Environment paths
export KNAI_REPO_PATH="$(pwd)"
export KNAI_LOG_PATH="$KNAI_REPO_PATH/logs/knai.log"
export KNAI_DATA_PATH="$KNAI_REPO_PATH/data"

# Run Python update cycle
python3 knai_system.py

# Push latest to GitHub
git add data/*
git commit -m "Auto-update KNAI"
git push origin main

# Restart Flask service (systemd)
sudo systemctl restart knai
chmod +x deploy.sh
name: Deploy KNAI
on:
  push:
    branches: [ main ]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.9"
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    - name: Deploy to Server
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      run: |
        echo "$SSH_PRIVATE_KEY" > key
        chmod 600 key
        rsync -avz --delete -e "ssh -i key -o StrictHostKeyChecking=no" . user@knai.ai:/var/www/knai
        ssh -i key -o StrictHostKeyChecking=no user@knai.ai "sudo systemctl restart knai"
import os
import subprocess
from datetime import datetime
from pathlib import Path
import logging
from logging.handlers import RotatingFileHandler

# ==========================
# Configuration
# ==========================
REPO_PATH = Path(os.getenv("KNAI_REPO_PATH", "/var/www/knai"))
DATA_PATH = Path(os.getenv("KNAI_DATA_PATH", REPO_PATH / "data"))
LOG_PATH = Path(os.getenv("KNAI_LOG_PATH", REPO_PATH / "logs/knai_deploy.log"))
REMOTE_USER = "user"
REMOTE_HOST = "knai.ai"
REMOTE_PATH = "/var/www/knai"
SYSTEMD_SERVICE = "knai"
SSH_KEY_PATH = Path("/tmp/knai_ssh_key")

# ==========================
# Setup Logging
# ==========================
LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
logger = logging.getLogger("KNAI_Deploy")
logger.setLevel(logging.INFO)
handler = RotatingFileHandler(LOG_PATH, maxBytes=5*1024*1024, backupCount=3)
handler.setFormatter(logging.Formatter("[{asctime}] {levelname}: {message}", style="{"))
logger.addHandler(handler)

# ==========================
# Functions
# ==========================
def run_command(cmd, check=True):
    logger.info(f"Running: {cmd}")
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    if result.returncode != 0 and check:
        logger.error(f"Command failed: {result.stderr}")
        raise Exception(f"Command failed: {cmd}")
    logger.info(result.stdout.strip())
    return result.stdout.strip()

def pull_latest_repo():
    logger.info("Pulling latest GitHub changes")
    run_command(f"git -C {REPO_PATH} pull origin main")

def generate_updates():
    logger.info("Generating latest KNAI updates")
    from knai_system import KnAiSystem, KnowledgeGraphAI, DataMarketplaceAI
    ais = [KnowledgeGraphAI(), DataMarketplaceAI()]
    kn_ai = KnAiSystem(
        ais=ais,
        repo_path=REPO_PATH,
        log_path=LOG_PATH,
        data_path=DATA_PATH
    )
    kn_ai.run_update_cycle()
    return kn_ai.latest_update

def deploy_to_server():
    logger.info("Deploying to remote server")
    ssh_key = os.getenv("SSH_PRIVATE_KEY")
    if not ssh_key:
        raise Exception("SSH_PRIVATE_KEY environment variable not set")
    SSH_KEY_PATH.write_text(ssh_key)
    SSH_KEY_PATH.chmod(0o600)
    
    # Rsync entire repo
    run_command(f'rsync -avz --delete -e "ssh -i {SSH_KEY_PATH} -o StrictHostKeyChecking=no" {REPO_PATH}/ {REMOTE_USER}@{REMOTE_HOST}:{REMOTE_PATH}')
    
    # Restart systemd service
    run_command(f'ssh -i {SSH_KEY_PATH} -o StrictHostKeyChecking=no {REMOTE_USER}@{REMOTE_HOST} "sudo systemctl restart {SYSTEMD_SERVICE}"')

# ==========================
# Main
# ==========================
if __name__ == "__main__":
    try:
        logger.info("===== KNAI Deployment Start =====")
        pull_latest_repo()
        generate_updates()
        deploy_to_server()
        logger.info("===== KNAI Deployment Completed Successfully =====")
    except Exception as e:
        logger.exception(f"Deployment failed: {e}")
        exit(1)
export SSH_PRIVATE_KEY="$(cat ~/.ssh/id_rsa)"
python3 deploy_knai.py
name: Deploy KNAI

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    # 1. Checkout repository
    - name: Checkout repository
      uses: actions/checkout@v3

    # 2. Setup Python
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.9"

    # 3. Install dependencies
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    # 4. Deploy using deploy_knai.py
    - name: Deploy KNAI
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        KNAI_REPO_PATH: ${{ github.workspace }}
        KNAI_DATA_PATH: ${{ github.workspace }}/data
        KNAI_LOG_PATH: ${{ github.workspace }}/logs/knai_deploy.log
      run: |
        python deploy_knai.py
knai_repo/deploy_knai.py
export SSH_PRIVATE_KEY="/path/to/private/key"
export KNAI_REPO_PATH="/path/to/knai_repo"
export KNAI_DATA_PATH="/path/to/knai_repo/data"
export KNAI_LOG_PATH="/path/to/knai_repo/logs/knai.log"
name: Deploy KNAI
on:
  push:
    branches: [ main ]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.9"
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Deploy with Python
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          KNAI_REPO_PATH: ${{ secrets.KNAI_REPO_PATH }}
          KNAI_DATA_PATH: ${{ secrets.KNAI_DATA_PATH }}
          KNAI_LOG_PATH: ${{ secrets.KNAI_LOG_PATH }}
        run: |
          python deploy_knai.py
[Unit]
Description=KNAI Flask App
After=network.target

[Service]
User=knai_user
WorkingDirectory=/path/to/knai_repo
ExecStart=/usr/bin/gunicorn -w 4 -b 0.0.0.0:5000 knai_system:app
Restart=always

[Install]
WantedBy=multi-user.target
sudo systemctl daemon-reload
sudo systemctl enable knai
sudo systemctl start knai
ln -sf /path/to/knai_repo/data/$(ls -t /path/to/knai_repo/data | head -1) /var/www/knai/knai_update_latest.html
import os
import shutil
import subprocess
from pathlib import Path
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from abc import ABC, abstractmethod
import logging
from logging.handlers import RotatingFileHandler
from flask import Flask, jsonify

# -----------------------------
# Logging
# -----------------------------
def setup_logging(log_path: str) -> logging.Logger:
    logger = logging.getLogger("KNAI_Deploy")
    logger.setLevel(logging.INFO)
    handler = RotatingFileHandler(log_path, maxBytes=5*1024*1024, backupCount=3)
    formatter = logging.Formatter("[{asctime}] {levelname}: {message}", style="{")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    return logger

# -----------------------------
# AI Interface
# -----------------------------
class AIInterface(ABC):
    @abstractmethod
    def generate_update(self) -> str:
        pass

# -----------------------------
# Example AI Implementations
# -----------------------------
class KnowledgeGraphAI(AIInterface):
    def generate_update(self) -> str:
        return f'{{"nodes": [{{"id": "n1", "label": "Concept A"}}, {{"id": "n2", "label": "Concept B"}}], "edges": [{{"from": "n1", "to": "n2", "relation": "related_to"}}]}}'

class DataMarketplaceAI(AIInterface):
    def generate_update(self) -> str:
        return f'{{"dataset_id": "ds{int(datetime.now().timestamp())}", "description": "New dataset", "price": "10 KNAI"}}'

# -----------------------------
# KNAI System
# -----------------------------
class KnAiSystem:
    def __init__(self, ais, repo_path, data_path, log_path, live_path):
        self.ais = ais
        self.repo_path = Path(repo_path)
        self.data_path = Path(data_path)
        self.live_path = Path(live_path)
        self.logger = setup_logging(log_path)
        self.latest_update = None
        self._validate_paths()

    def _validate_paths(self):
        for path in [self.repo_path, self.data_path, self.live_path]:
            path.mkdir(parents=True, exist_ok=True)
            if not os.access(path, os.W_OK):
                raise PermissionError(f"No write access to {path}")

    def pull_latest_code(self):
        self.logger.info("Pulling latest code from GitHub...")
        subprocess.run(['git', '-C', str(self.repo_path), 'pull', 'origin', 'main'], check=True)
        self.logger.info("Git pull completed.")

    def merge_ai_outputs(self, outputs):
        if not outputs:
            raise ValueError("No AI outputs to merge")
        return f'{{"updates": [{",".join(outputs)}]}}'

    def save_update_files(self, content):
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        html_file = self.data_path / f"knai_update_{timestamp}.html"
        json_file = self.data_path / f"knai_update_{timestamp}.json"

        # Save HTML
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head><title>KNAI Update</title></head>
        <body><pre>{content}</pre></body>
        </html>
        """
        html_file.write_text(html_content)
        self.logger.info(f"Saved HTML: {html_file.name}")

        # Save JSON
        json_file.write_text(content)
        self.logger.info(f"Saved JSON: {json_file.name}")

        # Update latest symlink
        latest_html = self.live_path / "knai_update_latest.html"
        if latest_html.exists() or latest_html.is_symlink():
            latest_html.unlink()
        latest_html.symlink_to(html_file.resolve())
        self.logger.info("Updated knai_update_latest.html symlink.")

        self.latest_update = content
        return html_file.name, json_file.name

    def generate_ai_updates(self):
        with ThreadPoolExecutor(max_workers=len(self.ais)) as executor:
            outputs = [f.result() for f in [executor.submit(ai.generate_update) for ai in self.ais]]
        for i, out in enumerate(outputs):
            self.logger.info(f"AI {i+1} output: {out[:50]}...")
        return self.merge_ai_outputs(outputs)

    def commit_to_github(self, files):
        repo = subprocess.run(['git', '-C', str(self.repo_path), 'add'] + [str(self.data_path / f) for f in files], check=True)
        subprocess.run(['git', '-C', str(self.repo_path), 'commit', '-m', f"KNAI auto-update {datetime.now().isoformat()}"], check=False)
        subprocess.run(['git', '-C', str(self.repo_path), 'push'], check=True)
        self.logger.info("Committed and pushed updates to GitHub.")

    def restart_service(self):
        self.logger.info("Restarting KNAI service...")
        subprocess.run(['systemctl', 'restart', 'knai'], check=True)
        self.logger.info("KNAI service restarted.")

    def run_update_cycle(self):
        self.logger.info("=== Starting KNAI update cycle ===")
        try:
            self.pull_latest_code()
            merged_content = self.generate_ai_updates()
            html_file, json_file = self.save_update_files(merged_content)
            self.commit_to_github([html_file, json_file])
            self.restart_service()
            self.logger.info("=== KNAI update cycle completed ===")
        except Exception as e:
            self.logger.error(f"Update cycle failed: {e}")
            raise

# -----------------------------
# Flask Web API
# -----------------------------
app = Flask(__name__)
kn_ai = None

@app.route("/api/updates", methods=["GET"])
def get_updates():
    if kn_ai.latest_update:
        return jsonify(kn_ai.latest_update)
    return jsonify({"error": "No updates available"}), 404

@app.route("/run-update", methods=["POST"])
def run_update():
    try:
        kn_ai.run_update_cycle()
        return jsonify({"status": "Update cycle completed"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# -----------------------------
# Main
# -----------------------------
if __name__ == "__main__":
    ais = [KnowledgeGraphAI(), DataMarketplaceAI()]
    kn_ai = KnAiSystem(
        ais=ais,
        repo_path=os.getenv("KNAI_REPO_PATH", "/var/www/knai_repo"),
        data_path=os.getenv("KNAI_DATA_PATH", "/var/www/knai_repo/data"),
        log_path=os.getenv("KNAI_LOG_PATH", "/var/www/knai_repo/logs/knai.log"),
        live_path=os.getenv("KNAI_LIVE_PATH", "/var/www/knai")
    )
    # Run once at startup
    kn_ai.run_update_cycle()
    # Start Flask API
    app.run(host="0.0.0.0", port=5000)
name: Auto-Deploy KNAI

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      # Step 1: Checkout repo
      - name: Checkout repository
        uses: actions/checkout@v3

      # Step 2: Set up Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.9"

      # Step 3: Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Step 4: Run KNAI update cycle
      - name: Run KNAI system
        run: |
          python knai_system.py

      # Step 5: Sync to remote server
      - name: Sync updates to server
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          echo "$SSH_PRIVATE_KEY" > key
          chmod 600 key
          rsync -avz --delete -e "ssh -i key -o StrictHostKeyChecking=no" ./data/ user@knai.ai:/path/to/knai/data/
          rsync -avz -e "ssh -i key -o StrictHostKeyChecking=no" ./logs/ user@knai.ai:/path/to/knai/logs/

      # Step 6: Restart KNAI service
      - name: Restart KNAI service
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          ssh -i key -o StrictHostKeyChecking=no user@knai.ai "systemctl restart knai"